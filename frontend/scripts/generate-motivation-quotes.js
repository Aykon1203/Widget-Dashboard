const fs = require('fs')
const path = require('path')

// Locate package installation and require the lib
function loadMotivation() {
  try {
    // Try direct require of package (works when running from frontend/)
    // The package exports an instance with getAll()
    const pkg = require('motivation')
    return pkg
  } catch (e) {
    // Fallback: try to resolve path inside node_modules (pnpm layout)
    try {
      const pkgPath = require.resolve('motivation')
      return require(pkgPath)
    } catch (err) {
      // try common pnpm path
      try {
        const alt = path.join(__dirname, '..', 'node_modules', '.pnpm')
        // Not deterministic; fallback to throwing
        throw err
      } catch (err2) {
        throw err
      }
    }
  }
}

function generate() {
  const outFile = path.join(__dirname, '..', 'src', 'services', 'motivation-quotes.ts')
  let quotes = []
  try {
    const mod = loadMotivation()
    const inst = mod?.default ?? mod
    if (inst && typeof inst.getAll === 'function') {
      quotes = inst.getAll()
    } else if (Array.isArray(inst)) {
      quotes = inst
    } else if (typeof inst.get === 'function') {
      // generate a set by calling get multiple times
      const set = new Set()
      for (let i = 0; i < 100 && set.size < 100; i++) {
        try { set.add(JSON.stringify(inst.get())) } catch (e) {}
      }
      quotes = Array.from(set).map(s => JSON.parse(s))
    }
  } catch (err) {
    console.warn('generate-motivation-quotes: failed to read motivation package, using minimal fallback', err && err.message)
  }

  // Normalize quotes to array of { text, author? }
  const normalized = (Array.isArray(quotes) ? quotes : []).map(q => {
    if (!q) return null
    if (typeof q === 'string') return { text: q }
    return { text: q.text ?? q.quote ?? q.body ?? '', author: q.author ?? q.by ?? '' }
  }).filter(Boolean)

  const content = `// Generated by scripts/generate-motivation-quotes.js â€” do not edit
export default ${JSON.stringify(normalized, null, 2)}
`

  fs.mkdirSync(path.dirname(outFile), { recursive: true })
  fs.writeFileSync(outFile, content, 'utf8')
  console.log('Wrote', outFile, 'with', normalized.length, 'quotes')
}

if (require.main === module) {
  generate()
}

module.exports = { generate }
